// Generated by CoffeeScript 1.8.0
(function() {
  "use strict";

  /**
  A directive for adding google places autocomplete to a text box
  google places autocomplete info: https://developers.google.com/maps/documentation/javascript/places
  
  Usage:
  
  <input type="text"  ng-autocomplete ng-model="autocomplete" options="options" details="details"/>
  
  + ng-model - autocomplete textbox value
  
  + details - more detailed autocomplete result, includes address parts, latlng, etc. (Optional)
  
  + options - configuration for the autocomplete (Optional)
  
  + types: type,        String, values can be 'geocode', 'establishment', '(regions)', or '(cities)'
  + bounds: bounds,     Google maps LatLngBounds Object, biases results to bounds, but may return results outside these bounds
  + country: country    String, ISO 3166-1 Alpha-2 compatible country code. examples; 'ca', 'us', 'gb'
  + watchEnter:         Boolean, true; on Enter select top autocomplete result. false(default); enter ends autocomplete
  + preventSubmit:      Boolean, true prevent default behavior on enter keydown event
  
  example:
  
  options = {
  types: '(cities)',
  country: 'ca'
  }
   */
  angular.module("ngAutocomplete", []).directive("ngAutocomplete", function() {
    return {
      require: "ngModel",
      scope: {
        ngModel: "=",
        options: "=?",
        details: "=?"
      },
      link: function(scope, element, attrs, controller) {
        var getPlace, preventSubmit, watchEnter;
        watchEnter = false;
        preventSubmit = true;
        scope.gPlace = new google.maps.places.Autocomplete(element[0], {});
        google.maps.event.addListener(scope.gPlace, "place_changed", function() {
          var result;
          result = scope.gPlace.getPlace();
          if (result !== undefined) {
            if (result.address_components !== undefined) {
              return scope.$apply(function() {
                scope.details = result;
                scope.$emit('addressEntrySelected', scope.details);
                return controller.$setViewValue(element.val());
              });
            } else {
              if (watchEnter) {
                getPlace(result);
                return element[0].blur();
              }
            }
          }
        });
        getPlace = function(result) {
          var autocompleteService, listentoresult;
          autocompleteService = new google.maps.places.AutocompleteService();
          if (result.name.length > 0) {
            return autocompleteService.getPlacePredictions({
              input: result.name,
              offset: result.name.length
            }, listentoresult = function(list, status) {
              var detailsresult, placesService;
              if ((list == null) || list.length === 0) {
                return scope.$apply(function() {
                  return scope.details = null;
                });
              } else {
                placesService = new google.maps.places.PlacesService(element[0]);
                return placesService.getDetails({
                  reference: list[0].reference
                }, detailsresult = function(detailsResult, placesServiceStatus) {
                  if (placesServiceStatus === google.maps.GeocoderStatus.OK) {
                    return scope.$apply(function() {
                      var watchFocusOut;
                      controller.$setViewValue(detailsResult.formatted_address);
                      element.val(detailsResult.formatted_address);
                      scope.details = detailsResult;
                      return watchFocusOut = element.on("blur", function(event) {
                        element.val(detailsResult.formatted_address);
                        return element.unbind("blur");
                      });
                    });
                  }
                });
              }
            });
          }
        };
        controller.$render = function() {
          var location;
          location = controller.$viewValue;
          return element.val(location);
        };
        scope.watchOptions = function() {
          return scope.options;
        };
        return scope.$watch(scope.watchOptions, (function() {
          if (scope.options) {
            watchEnter = !!scope.options.watchEnter;
            preventSubmit = !!scope.options.preventSubmit;
            if (scope.options.types) {
              scope.gPlace.setTypes([scope.options.types]);
            } else {
              scope.gPlace.setTypes([]);
            }
            if (scope.options.bounds) {
              scope.gPlace.setBounds(scope.options.bounds);
            } else {
              scope.gPlace.setBounds(null);
            }
            if (scope.options.country) {
              scope.gPlace.setComponentRestrictions({
                country: scope.options.country
              });
            } else {
              scope.gPlace.setComponentRestrictions(null);
            }
          }
          console.log(preventSubmit);
          if (preventSubmit) {
            return element.on('keydown', function(event) {
              var el, pacContainerElements, _i, _len, _results;
              if (event.which === 13) {
                pacContainerElements = document.getElementsByClassName('pac-container');
                _results = [];
                for (_i = 0, _len = pacContainerElements.length; _i < _len; _i++) {
                  el = pacContainerElements[_i];
                  if (el.style.display !== "none") {
                    _results.push(event.preventDefault());
                  } else {
                    _results.push(void 0);
                  }
                }
                return _results;
              }
            });
          }
        }), true);
      }
    };
  });

}).call(this);

//# sourceMappingURL=ngAutocomplete.js.map
